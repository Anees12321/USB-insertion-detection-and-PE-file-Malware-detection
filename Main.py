import tkinter as tk
from tkinter import filedialog, messagebox, ttk, scrolledtext
import wmi
import threading
import pythoncom
import requests
import time
import os
import pefile
import os
import array
import math
import pickle
import joblib
import sys
import argparse



METAD_DEFENDER_API_KEY = '91c452bcb71ffb2da85f4952fd63e323'

def get_entropy(data):
    if len(data) == 0:
        return 0.0
    occurences = array.array('L', [0] * 256)
    for x in data:
        occurences[x if isinstance(x, int) else ord(x)] += 1

    entropy = 0
    for x in occurences:
        if x:
            p_x = float(x) / len(data)
            entropy -= p_x * math.log(p_x, 2)

    return entropy


# For extracting the resources part
def get_resources(pe):
    """Extract resources :
    [entropy, size]"""
    resources = []
    if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
        try:
            for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                if hasattr(resource_type, 'directory'):
                    for resource_id in resource_type.directory.entries:
                        if hasattr(resource_id, 'directory'):
                            for resource_lang in resource_id.directory.entries:
                                data = pe.get_data(resource_lang.data.struct.OffsetToData,
                                                   resource_lang.data.struct.Size)
                                size = resource_lang.data.struct.Size
                                entropy = get_entropy(data)

                                resources.append([entropy, size])
        except Exception as e:
            return resources
    return resources


# For getting the version information
def get_version_info(pe):
    """Return version infos"""
    res = {}
    for fileinfo in pe.FileInfo:
        if fileinfo.Key == 'StringFileInfo':
            for st in fileinfo.StringTable:
                for entry in st.entries.items():
                    res[entry[0]] = entry[1]
        if fileinfo.Key == 'VarFileInfo':
            for var in fileinfo.Var:
                res[var.entry.items()[0][0]] = var.entry.items()[0][1]
    if hasattr(pe, 'VS_FIXEDFILEINFO'):
        res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
        res['os'] = pe.VS_FIXEDFILEINFO.FileOS
        res['type'] = pe.VS_FIXEDFILEINFO.FileType
        res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
        res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
        res['signature'] = pe.VS_FIXEDFILEINFO.Signature
        res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion
    return res


# extract the info for a given file using pefile
def extract_infos(fpath):
    res = {}
    pe = pefile.PE(fpath)
    res['Machine'] = pe.FILE_HEADER.Machine
    res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
    res['Characteristics'] = pe.FILE_HEADER.Characteristics
    res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
    res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
    res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
    res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
    res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
    res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
    res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
    try:
        res['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
    except AttributeError:
        res['BaseOfData'] = 0
    res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
    res['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
    res['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
    res['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
    res['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
    res['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
    res['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
    res['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
    res['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
    res['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
    res['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
    res['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
    res['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
    res['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
    res['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
    res['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
    res['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
    res['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
    res['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
    res['NumberOfRvaAndSizes'] = pe.OPTIONAL_HEADER.NumberOfRvaAndSizes

    # Sections
    res['SectionsNb'] = len(pe.sections)
    entropy = list(map(lambda x: x.get_entropy(), pe.sections))
    res['SectionsMeanEntropy'] = sum(entropy) / float(len((entropy)))
    res['SectionsMinEntropy'] = min(entropy)
    res['SectionsMaxEntropy'] = max(entropy)
    raw_sizes = list(map(lambda x: x.SizeOfRawData, pe.sections))
    res['SectionsMeanRawsize'] = sum(raw_sizes) / float(len((raw_sizes)))
    res['SectionsMinRawsize'] = min(raw_sizes)
    res['SectionsMaxRawsize'] = max(raw_sizes)
    virtual_sizes = list(map(lambda x: x.Misc_VirtualSize, pe.sections))
    res['SectionsMeanVirtualsize'] = sum(virtual_sizes) / float(len(virtual_sizes))
    res['SectionsMinVirtualsize'] = min(virtual_sizes)
    res['SectionMaxVirtualsize'] = max(virtual_sizes)

    # Imports
    try:
        res['ImportsNbDLL'] = len(pe.DIRECTORY_ENTRY_IMPORT)
        imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
        res['ImportsNb'] = len(imports)
        res['ImportsNbOrdinal'] = 0
    except AttributeError:
        res['ImportsNbDLL'] = 0
        res['ImportsNb'] = 0
        res['ImportsNbOrdinal'] = 0

    # Exports
    try:
        res['ExportNb'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
    except AttributeError:
        # No export
        res['ExportNb'] = 0
    # Resources
    resources = get_resources(pe)
    res['ResourcesNb'] = len(resources)
    if len(resources) > 0:
        entropy = list(map(lambda x: x[0], resources))
        res['ResourcesMeanEntropy'] = sum(entropy) / float(len(entropy))
        res['ResourcesMinEntropy'] = min(entropy)
        res['ResourcesMaxEntropy'] = max(entropy)
        sizes = list(map(lambda x: x[1], resources))
        res['ResourcesMeanSize'] = sum(sizes) / float(len(sizes))
        res['ResourcesMinSize'] = min(sizes)
        res['ResourcesMaxSize'] = max(sizes)
    else:
        res['ResourcesNb'] = 0
        res['ResourcesMeanEntropy'] = 0
        res['ResourcesMinEntropy'] = 0
        res['ResourcesMaxEntropy'] = 0
        res['ResourcesMeanSize'] = 0
        res['ResourcesMinSize'] = 0
        res['ResourcesMaxSize'] = 0

    # Load configuration size
    try:
        res['LoadConfigurationSize'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
    except AttributeError:
        res['LoadConfigurationSize'] = 0

    # Version configuration size
    try:
        version_infos = get_version_info(pe)
        res['VersionInformationSize'] = len(version_infos.keys())
    except AttributeError:
        res['VersionInformationSize'] = 0
    return res


def Results(file_path):
    # Load the trained classifier and features
    clf = joblib.load('classifiers&features/Classifier/classifier.pkl')
    features = pickle.loads(
        open(os.path.join('classifiers&features/Classifier/features.pkl'), 'rb').read())

    # Extract features from the specified PE file
    data = extract_infos(file_path)

    # Match the extracted features with the saved features list
    pe_features = [data[feature] for feature in features]

    # Predict if the PE is malicious or not based on the extracted features
    res = clf.predict([pe_features])[0]

    # Create the result string
    result_string = f"The file {os.path.basename(file_path)} is {'malicious' if res == 1 else 'legitimate'}"

    # Print features and results to console for debugging (optional)
    print("Features used for classification: ", pe_features)
    print(result_string)

    return result_string

def log(message):
    if log_text:
        log_text.configure(state='normal')
        log_text.insert(tk.END, message + "\n")
        log_text.configure(state='disabled')
        log_text.yview(tk.END)


def upload_file_to_metadefender(file_path):
    upload_url = 'https://api.metadefender.com/v4/file'
    headers = {'apikey': METAD_DEFENDER_API_KEY}
    files = {'file': (os.path.basename(file_path), open(file_path, 'rb'), 'application/octet-stream')}
    response = requests.post(upload_url, headers=headers, files=files)
    if response.status_code == 200:
        data_id = response.json()['data_id']
        report_url = f'https://api.metadefender.com/v4/file/{data_id}'
        while True:
            time.sleep(2)
            report_response = requests.get(report_url, headers=headers)
            if report_response.status_code == 200:
                report = report_response.json()
                if report['scan_results']['scan_all_result_a'] != 'In Progress':
                    return report
                else:
                    continue
            else:
                break
        return None
    return None


def save_scan_results(results, detected_count, total_engines, last_update):
    """Save the scan results to a file."""
    file_path = filedialog.asksaveasfilename(
        defaultextension=".txt",
        filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
        title="Save Report As"
    )
    if file_path:
        with open(file_path, 'w') as file:
            file.write("Scan Results:\n")
            file.write(f"Detected: {detected_count}/{total_engines}\n")
            file.write(f"Latest Update: {last_update}\n\n")
            for engine, detail in results['scan_results']['scan_details'].items():
                status = "Detected" if detail['threat_found'] else "No Threat Detected"
                threat_name = detail['threat_found'] if detail['threat_found'] else "No Threat"
                file.write(f"{threat_name}\t{engine}\t{detail['def_time']}\n")
        messagebox.showinfo("Save Successful", "The scan report has been saved successfully.")


def show_scan_results_popup(results):
    if results:
        popup = tk.Toplevel(root)
        popup.title("Scan Results")
        popup.geometry('600x500')

        frame = tk.Frame(popup)
        frame.pack(fill=tk.BOTH, expand=True)

        canvas = tk.Canvas(frame)
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=canvas.yview)
        scrollable_frame = ttk.Frame(canvas)

        scrollable_frame.bind(
            "<Configure>",
            lambda e: canvas.configure(scrollregion=canvas.bbox("all"))
        )

        canvas.create_window((0, 0), window=scrollable_frame, anchor="nw")
        canvas.configure(yscrollcommand=scrollbar.set)

        canvas.pack(side="left", fill="both", expand=True)
        scrollbar.pack(side="right", fill="y")

        # Calculate detection ratio and latest update date
        detected_count = sum(1 for detail in results['scan_results']['scan_details'].values() if detail['threat_found'])
        total_engines = len(results['scan_results']['scan_details'])
        last_update = max(detail['def_time'] for detail in results['scan_results']['scan_details'].values())

        # Displaying the detection ratio and last update date
        ratio_label = tk.Label(scrollable_frame, text=f"{detected_count}/{total_engines}", font=("Helvetica", 16),
                               fg="red")
        ratio_label.grid(row=0, column=0, columnspan=3, pady=(10, 0))
        date_label = tk.Label(scrollable_frame, text=f"Latest Update: {last_update}", font=("Helvetica", 12))
        date_label.grid(row=1, column=0, columnspan=3, pady=(0, 10))

        # Column Headings
        tk.Label(scrollable_frame, text="Result", font=("Helvetica", 10), borderwidth=2, relief="groove").grid(row=2,
                                                                                                               column=0,
                                                                                                               sticky="ew")
        tk.Label(scrollable_frame, text="Engine", font=("Helvetica", 10), borderwidth=2, relief="groove").grid(row=2,
                                                                                                               column=1,
                                                                                                               sticky="ew")
        tk.Label(scrollable_frame, text="Last Update", font=("Helvetica", 10), borderwidth=2, relief="groove").grid(
            row=2, column=2, sticky="ew")

        # Result Rows
        for i, (engine, detail) in enumerate(results['scan_results']['scan_details'].items(), start=3):
            status = "Detected" if detail['threat_found'] else "No Threat Detected"
            threat_name = detail['threat_found'] if detail['threat_found'] else "No Threat"
            tk.Label(scrollable_frame, text=f"{threat_name}", borderwidth=2, relief="groove").grid(row=i, column=0,
                                                                                                   sticky="ew")
            tk.Label(scrollable_frame, text=f"{engine}", borderwidth=2, relief="groove").grid(row=i, column=1,
                                                                                              sticky="ew")
            tk.Label(scrollable_frame, text=f"{detail['def_time']}", borderwidth=2, relief="groove").grid(row=i,
                                                                                                          column=2,
                                                                                                          sticky="ew")

        scrollable_frame.grid_columnconfigure(0, weight=1)
        scrollable_frame.grid_columnconfigure(1, weight=1)
        scrollable_frame.grid_columnconfigure(2, weight=1)

        # Save and Close buttons
        button_frame = ttk.Frame(popup)
        button_frame.pack(fill='x', pady=10)
        ttk.Button(button_frame, text="Save",
                   command=lambda: save_scan_results(results, detected_count, total_engines, last_update)).pack(
            side='left', padx=10)
        ttk.Button(button_frame, text="Close", command=popup.destroy).pack(side='right', padx=10)


def find_usb_drive():
    c = wmi.WMI()
    usb_drives = []
    for disk in c.Win32_LogicalDisk(DriveType=2):
        usb_drives.append(disk.DeviceID)
    return usb_drives[0] if usb_drives else None

def run_metadefender_scan():
    usb_drive = find_usb_drive()
    if not usb_drive:
        messagebox.showwarning("Warning", "No USB drive detected.")
        return

    file_path = filedialog.askopenfilename(initialdir=usb_drive, title="Select a file to scan")
    if file_path:
        log(f"Running MetaDefender scan for {file_path}")
        results = upload_file_to_metadefender(file_path)
        if results:
            show_scan_results_popup(results)
        else:
            log("Failed to get scan results.")
    else:
        log("No file selected for scanning.")

def run_ml_scan():
    usb_drive = find_usb_drive()
    if not usb_drive:
        messagebox.showwarning("Warning", "No USB drive detected.")
        return

    file_path = filedialog.askopenfilename(initialdir=usb_drive, title="Select a file to scan",
                                           filetypes=[("Executable files", "*.exe"), ("All files", "*.*")])
    if file_path:
        log(f"Running Machine Learning scan for file: {os.path.basename(file_path)}")
        result = Results(file_path)
        if result:
            log(result)  # Log the result to the text widget
            messagebox.showinfo("Scan Results", result)  # Display in a message box
        else:
            log("No result returned from scan.")
    else:
        log("No file selected for scanning.")

def list_files_in_drive(drive):
    """List files and directories in the given drive."""
    if os.path.exists(drive):
        try:
            files = os.listdir(drive)
            log(f"Contents of {drive}:")
            for file in files:
                log(f" - {file}")
        except Exception as e:
            log(f"Error accessing {drive}: {str(e)}")
    else:
        log(f"{drive} is not accessible.")

def fetch_usb_contents():
    """Fetch contents of the D:/ drive."""
    drive = "D:/"  # Directly specifying the drive letter
    list_files_in_drive(drive)

# Setup GUI
root = tk.Tk()
root.title("USB Drive file Analyzer")

# Buttons
fetch_button = tk.Button(root, text="Fetch USB Contents", command=fetch_usb_contents)
fetch_button.pack(pady=10)

ml_scan_button = tk.Button(root, text="Run Machine Learning Scan", command=run_ml_scan)
ml_scan_button.pack(pady=10)

md_button = tk.Button(root, text="Run MetaDefender Scan", command=run_metadefender_scan)
md_button.pack(pady=10)

log_text = scrolledtext.ScrolledText(root, state='disabled', height=10, width=50)
log_text.pack(pady=10)



monitoring = False

global_usb_drive = None

root.mainloop()
